class_map = {
    "AnalysisNwbfileKachery": {
        "sharing_kachery": "spyglass.sharing.sharing_kachery"
    },
    "AnalysisNwbfileKacherySelection": {
        "sharing_kachery": "spyglass.sharing.sharing_kachery"
    },
    "KacheryZone": {"sharing_kachery": "spyglass.sharing.sharing_kachery"},
    "DecodingOutput": {"decoding_merge": "spyglass.decoding.decoding_merge"},
    "SortedSpikesDecodingSelection": {
        "decoding_sorted_spikes_v1": "spyglass.decoding.v1.sorted_spikes"
    },
    "SortedSpikesDecodingV1": {
        "decoding_sorted_spikes_v1": "spyglass.decoding.v1.sorted_spikes"
    },
    "DecodingParameters": {"decoding_core_v1": "spyglass.decoding.v1.core"},
    "PositionGroup": {"decoding_core_v1": "spyglass.decoding.v1.core"},
    "UnitWaveformFeatures": {
        "decoding_waveform_features": "spyglass.decoding.v1.waveform_features"
    },
    "UnitWaveformFeaturesSelection": {
        "decoding_waveform_features": "spyglass.decoding.v1.waveform_features"
    },
    "WaveformFeaturesParams": {
        "decoding_waveform_features": "spyglass.decoding.v1.waveform_features"
    },
    "ClusterlessDecodingSelection": {
        "decoding_clusterless_v1": "spyglass.decoding.v1.clusterless"
    },
    "ClusterlessDecodingV1": {
        "decoding_clusterless_v1": "spyglass.decoding.v1.clusterless"
    },
    "UnitWaveformFeaturesGroup": {
        "decoding_clusterless_v1": "spyglass.decoding.v1.clusterless"
    },
    "SortedSpikesClassifierParameters": {
        "decoding_sortedspikes": "spyglass.decoding.v0.sorted_spikes"
    },
    "SortedSpikesIndicator": {
        "decoding_sortedspikes": "spyglass.decoding.v0.sorted_spikes"
    },
    "SortedSpikesIndicatorSelection": {
        "decoding_sortedspikes": "spyglass.decoding.v0.sorted_spikes"
    },
    "ClusterlessClassifierParameters": {
        "decoding_clusterless": "spyglass.decoding.v0.clusterless"
    },
    "MarkParameters": {
        "decoding_clusterless": "spyglass.decoding.v0.clusterless"
    },
    "UnitMarkParameters": {
        "decoding_clusterless": "spyglass.decoding.v0.clusterless"
    },
    "UnitMarks": {"decoding_clusterless": "spyglass.decoding.v0.clusterless"},
    "UnitMarksIndicator": {
        "decoding_clusterless": "spyglass.decoding.v0.clusterless"
    },
    "UnitMarksIndicatorSelection": {
        "decoding_clusterless": "spyglass.decoding.v0.clusterless"
    },
    "DandiPath": {"common_dandi": "spyglass.common.common_dandi"},
    "Session": {"common_session": "spyglass.common.common_session"},
    "Task": {"common_task": "spyglass.common.common_task"},
    "TaskEpoch": {"common_task": "spyglass.common.common_task"},
    "AnalysisNwbfile": {"common_nwbfile": "spyglass.common.common_nwbfile"},
    "AnalysisNwbfileLog": {"common_nwbfile": "spyglass.common.common_nwbfile"},
    "Nwbfile": {"common_nwbfile": "spyglass.common.common_nwbfile"},
    "FirFilterParameters": {"common_filter": "spyglass.common.common_filter"},
    "BrainRegion": {"common_region": "spyglass.common.common_region"},
    "Electrode": {"common_ephys": "spyglass.common.common_ephys"},
    "ElectrodeGroup": {"common_ephys": "spyglass.common.common_ephys"},
    "LFP": {"common_ephys": "spyglass.common.common_ephys"},
    "LFPBand": {"common_ephys": "spyglass.common.common_ephys"},
    "LFPBandSelection": {
        "common_ephys": "spyglass.common.common_ephys",
        "lfp_band_v1": "spyglass.lfp.analysis.v1.lfp_band",
    },
    "LFPSelection": {
        "common_ephys": "spyglass.common.common_ephys",
        "lfp_v1": "spyglass.lfp.v1.lfp",
    },
    "Raw": {"common_ephys": "spyglass.common.common_ephys"},
    "SampleCount": {"common_ephys": "spyglass.common.common_ephys"},
    "CameraDevice": {"common_device": "spyglass.common.common_device"},
    "DataAcquisitionDevice": {"common_device": "spyglass.common.common_device"},
    "DataAcquisitionDeviceAmplifier": {
        "common_device": "spyglass.common.common_device"
    },
    "DataAcquisitionDeviceSystem": {
        "common_device": "spyglass.common.common_device"
    },
    "Probe": {"common_device": "spyglass.common.common_device"},
    "ProbeType": {"common_device": "spyglass.common.common_device"},
    "Subject": {"common_subject": "spyglass.common.common_subject"},
    "PositionIntervalMap": {"common_behav": "spyglass.common.common_behav"},
    "PositionSource": {"common_behav": "spyglass.common.common_behav"},
    "RawPosition": {"common_behav": "spyglass.common.common_behav"},
    "StateScriptFile": {"common_behav": "spyglass.common.common_behav"},
    "VideoFile": {"common_behav": "spyglass.common.common_behav"},
    "IntervalList": {"common_interval": "spyglass.common.common_interval"},
    "ActivityLog": {"common_usage": "spyglass.common.common_usage"},
    "CautiousDelete": {"common_usage": "spyglass.common.common_usage"},
    "Export": {"common_usage": "spyglass.common.common_usage"},
    "ExportSelection": {"common_usage": "spyglass.common.common_usage"},
    "InsertError": {"common_usage": "spyglass.common.common_usage"},
    "DIOEvents": {"common_dio": "spyglass.common.common_dio"},
    "SensorData": {"common_sensors": "spyglass.common.common_sensors"},
    "Institution": {"common_lab": "spyglass.common.common_lab"},
    "Lab": {"common_lab": "spyglass.common.common_lab"},
    "LabMember": {"common_lab": "spyglass.common.common_lab"},
    "LabTeam": {"common_lab": "spyglass.common.common_lab"},
    "IntervalLinearizationSelection": {
        "common_position": "spyglass.linearization.v0.main"
    },
    "IntervalLinearizedPosition": {
        "common_position": "spyglass.linearization.v0.main"
    },
    "IntervalPositionInfo": {
        "common_position": "spyglass.linearization.v0.main"
    },
    "IntervalPositionInfoSelection": {
        "common_position": "spyglass.common.common_position"
    },
    "LinearizationParameters": {
        "common_position": "spyglass.linearization.v0.main",
        "position_linearization_v1": "spyglass.linearization.v1.main",
    },
    "PositionInfoParameters": {
        "common_position": "spyglass.common.common_position"
    },
    "PositionVideo": {"common_position": "spyglass.common.common_position"},
    "TrackGraph": {
        "common_position": "spyglass.linearization.v0.main",
        "position_linearization_v1": "spyglass.linearization.v1.main",
    },
    "MuaEventsParameters": {"mua_v1": "spyglass.mua.v1.mua"},
    "MuaEventsV1": {"mua_v1": "spyglass.mua.v1.mua"},
    "LFPElectrodeGroup": {"lfp_electrode": "spyglass.lfp.lfp_electrode"},
    "LFPOutput": {"lfp_merge": "spyglass.lfp.lfp_merge"},
    "ImportedLFP": {"lfp_imported": "spyglass.lfp.lfp_imported"},
    "LFPV1": {"lfp_v1": "spyglass.lfp.v1.lfp_artifact"},
    "LFPArtifactDetection": {"lfp_v1": "spyglass.lfp.v1.lfp_artifact"},
    "LFPArtifactDetectionParameters": {
        "lfp_v1": "spyglass.lfp.v1.lfp_artifact"
    },
    "LFPArtifactDetectionSelection": {"lfp_v1": "spyglass.lfp.v1.lfp_artifact"},
    "LFPArtifactRemovedIntervalList": {
        "lfp_v1": "spyglass.lfp.v1.lfp_artifact"
    },
    "LFPBandV1": {"lfp_band_v1": "spyglass.lfp.analysis.v1.lfp_band"},
    "ImportedSpikeSorting": {
        "spikesorting_imported": "spyglass.spikesorting.imported"
    },
    "SpikeSortingOutput": {
        "spikesorting_merge": "spyglass.spikesorting.spikesorting_merge"
    },
    "SpikeSorterParameters": {
        "spikesorting_v1_sorting": "spyglass.spikesorting.v1.sorting",
        "spikesorting_sorting": "spyglass.spikesorting.v0.spikesorting_sorting",
    },
    "SpikeSorting": {
        "spikesorting_v1_sorting": "spyglass.spikesorting.v1.sorting",
        "spikesorting_sorting": "spyglass.spikesorting.v0.spikesorting_sorting",
    },
    "SpikeSortingSelection": {
        "spikesorting_v1_sorting": "spyglass.spikesorting.v1.sorting",
        "spikesorting_sorting": "spyglass.spikesorting.v0.spikesorting_sorting",
    },
    "FigURLCuration": {
        "spikesorting_v1_figurl_curation": "spyglass.spikesorting.v1.figurl_curation"
    },
    "FigURLCurationSelection": {
        "spikesorting_v1_figurl_curation": "spyglass.spikesorting.v1.figurl_curation"
    },
    "MetricCuration": {
        "spikesorting_v1_metric_curation": "spyglass.spikesorting.v1.metric_curation"
    },
    "MetricCurationParameters": {
        "spikesorting_v1_metric_curation": "spyglass.spikesorting.v1.metric_curation"
    },
    "MetricCurationSelection": {
        "spikesorting_v1_metric_curation": "spyglass.spikesorting.v1.metric_curation"
    },
    "MetricParameters": {
        "spikesorting_v1_metric_curation": "spyglass.spikesorting.v1.metric_curation",
        "spikesorting_curation": "spyglass.spikesorting.v0.spikesorting_curation",
    },
    "WaveformParameters": {
        "spikesorting_v1_metric_curation": "spyglass.spikesorting.v1.metric_curation",
        "spikesorting_curation": "spyglass.spikesorting.v0.spikesorting_curation",
    },
    "ArtifactDetection": {
        "spikesorting_v1_artifact": "spyglass.spikesorting.v1.artifact",
        "spikesorting_artifact": "spyglass.spikesorting.v0.spikesorting_artifact",
    },
    "ArtifactDetectionParameters": {
        "spikesorting_v1_artifact": "spyglass.spikesorting.v1.artifact",
        "spikesorting_artifact": "spyglass.spikesorting.v0.spikesorting_artifact",
    },
    "ArtifactDetectionSelection": {
        "spikesorting_v1_artifact": "spyglass.spikesorting.v1.artifact",
        "spikesorting_artifact": "spyglass.spikesorting.v0.spikesorting_artifact",
    },
    "SortGroup": {
        "spikesorting_v1_recording": "spyglass.spikesorting.v1.recording",
        "spikesorting_recording": "spyglass.spikesorting.v0.spikesorting_recording",
    },
    "SpikeSortingPreprocessingParameters": {
        "spikesorting_v1_recording": "spyglass.spikesorting.v1.recording",
        "spikesorting_recording": "spyglass.spikesorting.v0.spikesorting_recording",
    },
    "SpikeSortingRecording": {
        "spikesorting_v1_recording": "spyglass.spikesorting.v1.recording",
        "spikesorting_recording": "spyglass.spikesorting.v0.spikesorting_recording",
    },
    "SpikeSortingRecordingSelection": {
        "spikesorting_v1_recording": "spyglass.spikesorting.v1.recording",
        "spikesorting_recording": "spyglass.spikesorting.v0.spikesorting_recording",
    },
    "CurationV1": {
        "spikesorting_v1_curation": "spyglass.spikesorting.v1.curation"
    },
    "SortedSpikesGroup": {
        "spikesorting_group_v1": "spyglass.spikesorting.analysis.v1.group"
    },
    "UnitSelectionParams": {
        "spikesorting_group_v1": "spyglass.spikesorting.analysis.v1.group"
    },
    "UnitAnnotation": {
        "spikesorting_unit_annotation_v1": "spyglass.spikesorting.analysis.v1.unit_annotation"
    },
    "CurationFigurl": {
        "spikesorting_curation_figurl": "spyglass.spikesorting.v0.curation_figurl"
    },
    "CurationFigurlSelection": {
        "spikesorting_curation_figurl": "spyglass.spikesorting.v0.curation_figurl"
    },
    "SpikeSortingPipelineParameters": {
        "spikesorting_sorting": "spyglass.spikesorting.v0.spikesorting_populator"
    },
    "ArtifactRemovedIntervalList": {
        "spikesorting_artifact": "spyglass.spikesorting.v0.spikesorting_artifact"
    },
    "SortingviewWorkspace": {
        "spikesorting_sortingview": "spyglass.spikesorting.v0.sortingview"
    },
    "SortingviewWorkspaceSelection": {
        "spikesorting_sortingview": "spyglass.spikesorting.v0.sortingview"
    },
    "SortInterval": {
        "spikesorting_recording": "spyglass.spikesorting.v0.spikesorting_recording"
    },
    "AutomaticCuration": {
        "spikesorting_curation": "spyglass.spikesorting.v0.spikesorting_curation"
    },
    "AutomaticCurationParameters": {
        "spikesorting_curation": "spyglass.spikesorting.v0.spikesorting_curation"
    },
    "AutomaticCurationSelection": {
        "spikesorting_curation": "spyglass.spikesorting.v0.spikesorting_curation"
    },
    "CuratedSpikeSorting": {
        "spikesorting_curation": "spyglass.spikesorting.v0.spikesorting_curation"
    },
    "CuratedSpikeSortingSelection": {
        "spikesorting_curation": "spyglass.spikesorting.v0.spikesorting_curation"
    },
    "Curation": {
        "spikesorting_curation": "spyglass.spikesorting.v0.spikesorting_curation"
    },
    "MetricSelection": {
        "spikesorting_curation": "spyglass.spikesorting.v0.spikesorting_curation"
    },
    "QualityMetrics": {
        "spikesorting_curation": "spyglass.spikesorting.v0.spikesorting_curation"
    },
    "WaveformSelection": {
        "spikesorting_curation": "spyglass.spikesorting.v0.spikesorting_curation"
    },
    "Waveforms": {
        "spikesorting_curation": "spyglass.spikesorting.v0.spikesorting_curation"
    },
    "LinearizedPositionOutput": {
        "position_linearization_merge": "spyglass.linearization.merge"
    },
    "LinearizationSelection": {
        "position_linearization_v1": "spyglass.linearization.v1.main"
    },
    "LinearizedPositionV1": {
        "position_linearization_v1": "spyglass.linearization.v1.main"
    },
    "PositionOutput": {"position_merge": "spyglass.position.position_merge"},
    "DLCSmoothInterp": {
        "position_v1_dlc_position": "spyglass.position.v1.position_dlc_position"
    },
    "DLCSmoothInterpParams": {
        "position_v1_dlc_position": "spyglass.position.v1.position_dlc_position"
    },
    "DLCSmoothInterpSelection": {
        "position_v1_dlc_position": "spyglass.position.v1.position_dlc_position"
    },
    "DLCPoseEstimation": {
        "position_v1_dlc_pose_estimation": "spyglass.position.v1.position_dlc_pose_estimation"
    },
    "DLCPoseEstimationSelection": {
        "position_v1_dlc_pose_estimation": "spyglass.position.v1.position_dlc_pose_estimation"
    },
    "DLCSmoothInterpCohort": {
        "position_v1_dlc_cohort": "spyglass.position.v1.position_dlc_cohort"
    },
    "DLCSmoothInterpCohortSelection": {
        "position_v1_dlc_cohort": "spyglass.position.v1.position_dlc_cohort"
    },
    "TrodesPosParams": {
        "position_v1_trodes_position": "spyglass.position.v1.position_trodes_position"
    },
    "TrodesPosSelection": {
        "position_v1_trodes_position": "spyglass.position.v1.position_trodes_position"
    },
    "TrodesPosV1": {
        "position_v1_trodes_position": "spyglass.position.v1.position_trodes_position"
    },
    "TrodesPosVideo": {
        "position_v1_trodes_position": "spyglass.position.v1.position_trodes_position"
    },
    "DLCOrientation": {
        "position_v1_dlc_orient": "spyglass.position.v1.position_dlc_orient"
    },
    "DLCOrientationParams": {
        "position_v1_dlc_orient": "spyglass.position.v1.position_dlc_orient"
    },
    "DLCOrientationSelection": {
        "position_v1_dlc_orient": "spyglass.position.v1.position_dlc_orient"
    },
    "DLCModelTraining": {
        "position_v1_dlc_training": "spyglass.position.v1.position_dlc_training"
    },
    "DLCModelTrainingParams": {
        "position_v1_dlc_training": "spyglass.position.v1.position_dlc_training"
    },
    "DLCModelTrainingSelection": {
        "position_v1_dlc_training": "spyglass.position.v1.position_dlc_training"
    },
    "DLCCentroid": {
        "position_v1_dlc_centroid": "spyglass.position.v1.position_dlc_centroid"
    },
    "DLCCentroidParams": {
        "position_v1_dlc_centroid": "spyglass.position.v1.position_dlc_centroid"
    },
    "DLCCentroidSelection": {
        "position_v1_dlc_centroid": "spyglass.position.v1.position_dlc_centroid"
    },
    "BodyPart": {
        "position_v1_dlc_project": "spyglass.position.v1.position_dlc_project"
    },
    "DLCProject": {
        "position_v1_dlc_project": "spyglass.position.v1.position_dlc_project"
    },
    "DLCModel": {
        "position_v1_dlc_model": "spyglass.position.v1.position_dlc_model"
    },
    "DLCModelEvaluation": {
        "position_v1_dlc_model": "spyglass.position.v1.position_dlc_model"
    },
    "DLCModelInput": {
        "position_v1_dlc_model": "spyglass.position.v1.position_dlc_model"
    },
    "DLCModelParams": {
        "position_v1_dlc_model": "spyglass.position.v1.position_dlc_model"
    },
    "DLCModelSelection": {
        "position_v1_dlc_model": "spyglass.position.v1.position_dlc_model"
    },
    "DLCModelSource": {
        "position_v1_dlc_model": "spyglass.position.v1.position_dlc_model"
    },
    "DLCPosSelection": {
        "position_v1_dlc_selection": "spyglass.position.v1.position_dlc_selection"
    },
    "DLCPosV1": {
        "position_v1_dlc_selection": "spyglass.position.v1.position_dlc_selection"
    },
    "DLCPosVideo": {
        "position_v1_dlc_selection": "spyglass.position.v1.position_dlc_selection"
    },
    "DLCPosVideoParams": {
        "position_v1_dlc_selection": "spyglass.position.v1.position_dlc_selection"
    },
    "DLCPosVideoSelection": {
        "position_v1_dlc_selection": "spyglass.position.v1.position_dlc_selection"
    },
    "RippleLFPSelection": {"ripple_v1": "spyglass.ripple.v1.ripple"},
    "RippleParameters": {"ripple_v1": "spyglass.ripple.v1.ripple"},
    "RippleTimesV1": {"ripple_v1": "spyglass.ripple.v1.ripple"},
}
import importlib
import inspect
from collections import defaultdict
from functools import cached_property
from itertools import product as iter_product
from pathlib import Path
from typing import Any, Dict, List, Tuple

import datajoint as dj
from datajoint import Table
from datajoint.utils import to_camel_case

from spyglass.common.common_session import Session
from spyglass.lfp.lfp_merge import ImportedLFP  # for cascade
from spyglass.linearization.merge import LinearizedPositionOutput as LO
from spyglass.utils.database_settings import SHARED_MODULES
from spyglass.utils.dj_graph import Direction, RestrGraph, TableChain
from spyglass.utils.dj_helper_fn import ensure_names
from spyglass.utils.replication import class_map


class ImportedGraph(RestrGraph):
    def __init__(
        self,
        target: RestrGraph,
        new_tbl: Table,
        new_restr: str = None,
        class_map: dict = None,
        banned_tables: list = None,
        cascade: bool = True,
        *args,
        **kwargs,
    ):
        kwargs["verbose"] = True  # TODO: remove

        banned_tables = banned_tables or []
        banned_tables.extend(list(target.graph.nodes - target.visited))

        self._class_map = class_map
        self.target = target

        super().__init__(
            banned_tables=banned_tables,
            seed_table=new_tbl,
            leaves={
                "table_name": new_tbl.full_table_name,
                "restriction": new_restr,
            },
            direction="up",
            cascade=True,
            *args,
            **kwargs,
        )

        self.cascaded = False
        self.to_visit = self._topo_sort(self.target.visited - self.visited)

        if cascade:
            self.cascade_target()
            self.cascaded = True

    def merged_list_of_dicts(self, *args):
        # TODO: accept list from multi-table fetches
        merged = []
        for combo in iter_product(*args):
            new = dict()
            for this_dict in combo:
                new.update(this_dict)
            merged.append(new)
        return merged

    def cascade1_target(self, next_tbl: str = None):
        target = self.target

        # Find next table to cascade to
        next_tbl = next_tbl or self.find_cascade_stop()

        self._log_truncate(f"Next   : {next_tbl}")

        # Find that table's parents
        all_parents = set(self._get_ft(next_tbl).parents())
        filled_parents = all_parents & self.visited  # Already visited
        next_parents = all_parents - self.visited  # Need to check target

        self._log_truncate(f"Next   : {next_tbl}, {next_parents}")

        # Parent keys.
        # Use all combinations, assume want all given self.parent restriction
        # List[List[Dict[str, str]]] N_parents[N_keys] # Parent keys
        parent_keys = []
        for parent in filled_parents:
            attr_map = self._get_edge(parent, next_tbl)[1]["attr_map"]
            parent_keys.append(self._get_key(parent, attr_map=attr_map))
        for parent in next_parents:
            attr_map = self._get_edge(parent, next_tbl)[1]["attr_map"]
            parent_keys.append(target._get_key(parent, attr_map=attr_map))
        next_inserts = self.merged_list_of_dicts(*parent_keys)

        # Populate or insert next table
        next_class = self._get_class(next_tbl, with_restr=False)
        if isinstance(next_class, (dj.Imported, dj.Computed)):
            self._log_truncate(f"AutoPop: {next_tbl}")
            next_class.populate(next_inserts)
        else:  # Insert directly
            self._log_truncate(f"Insert : {next_tbl}")
            next_class.insert(next_inserts, skip_duplicates=True)

        # Cascade to next table
        self.cascade1(next(iter(filled_parents)), direction=Direction.DOWN)

        # TODO: gets hung up on selection table before a merge

        self.to_visit.remove(next_tbl)

    def cascade_target(self, limit=20):
        while limit > 0 and self.to_visit:
            self.cascade1_target()
            limit -= 1

    def find_cascade_stop(self):
        """Find the first table in the chain without a restriction."""
        for table in self.non_alias(self.to_visit):
            if self._get_restr(table) is None:
                return table
        return None

    # -------------------- Map Package for Importing Class --------------------
    # This is needed to run populate on tables directly.
    # Dict[Class, Dict[Schema, Module]

    @cached_property
    def class_map(self):
        if not self._class_map:
            self._class_map = self._map_package()
        return self._class_map

    def _set_class(self, table_name: str, class_obj: Any) -> None:
        """Set class object for table name."""
        self._set_node(table_name, "class", class_obj)

    def _get_class(self, table_name: str, with_restr=True) -> Any:
        """Get class object for table name."""
        class_obj = self._get_node(table_name).get("class")
        if not class_obj:
            class_obj = self._import_class(table_name)
        if isinstance(class_obj, dj.user_tables.TableMeta):
            class_obj = class_obj()
        if not with_restr:
            return class_obj
        return class_obj & self._get_restr(table_name)

    @cached_property
    def database_map(self) -> Dict[str, List[str]]:
        """Map all tables in the shared database

        Format: {schema: [table1, table2, ...]}
        """

        cmd = """
        SELECT
            TABLE_SCHEMA AS database_name,
            TABLE_NAME AS table_name
        FROM
            information_schema.tables
        WHERE
            TABLE_TYPE = 'BASE TABLE'
        ORDER BY
            TABLE_SCHEMA, TABLE_NAME;
        """

        all_tables = dj.conn().query(cmd).fetchall()
        ret = defaultdict(list)
        for schema, table in all_tables:
            if (
                schema.split("_")[0] not in SHARED_MODULES  # ignore custom
                or table[0] == "~"  # ignore log tables
                or "__" in table[1:]  # ignore part tables
            ):
                continue
            ret[schema].append(to_camel_case(table))
        return ret

    def _map_package(self) -> dict:
        package_name = "spyglass"
        package = importlib.import_module("spyglass")
        package_path = Path(package.__file__).parent

        class_map = defaultdict(dict)

        for py_file in package_path.rglob("*.py"):
            if py_file.stem.startswith("_"):
                continue

            # Convert file path to module path
            relative_path = py_file.relative_to(package_path)
            module_name = (
                f"{package_name}.{relative_path.with_suffix('')}".replace(
                    "/", "."
                ).replace("\\", ".")
            )

            try:
                module = importlib.import_module(module_name)
            except ImportError:
                continue

            # Check if the module has a `schema` object
            schema_obj = getattr(module, "schema", None)
            if not schema_obj:
                continue

            schema_name = getattr(schema_obj, "database")
            entry = {schema_name: module_name}

            # Map class names to schema and module names
            db_tables = self.database_map.get(schema_name, [])
            for name, obj in inspect.getmembers(module, inspect.isclass):
                if name not in db_tables:
                    continue
                class_map[name].update(entry)
                full_name = obj.full_table_name
                if self.graph.nodes.get(full_name):
                    self._set_class(full_name, obj)

            # TODO: is the class map needed if the obj is added here?
            #       Need to re-init anyway if needed table isn't in graph

        return dict(class_map)

    def _decompose_name(self, name: str) -> Tuple[str, str, str]:
        """Decompose table name into schema and table name."""
        schema, table = ensure_names(name).strip("`").split(".")
        part = None
        if "__" in table and "`__" not in table:
            table, part = table.split("__")
        return schema, self._camel(table), self._camel(part)

    def _import_class(self, table_name: str) -> Any:
        schema_name, class_name, part_name = self._decompose_name(table_name)
        class_map = self.class_map
        module_name = class_map.get(class_name, {}).get(schema_name.strip("`"))

        if not module_name:
            raise ImportError(f"Class {class_name} not found in the package.")

        module = importlib.import_module(module_name)
        table_class = getattr(module, class_name)
        if part_name:
            table_class = getattr(table_class, part_name)
        return table_class


if __name__ == "__main__":
    ta = RestrGraph(
        seed_table=LO(),
        leaves={
            LO.full_table_name: "source='LinearizedPositionV1'",
        },
        direction="up",
        verbose=False,
        cascade=True,
    )

    new_file = "minirec20230621_.nwb"
    new_dict = {"nwb_file_name": new_file}
    oc = ImportedGraph(
        class_map=class_map,
        target=ta,
        new_tbl=Session(),
        new_restr=new_dict,
        banned_tables=list(ta.no_visit),
        verbose=True,
    )
    oc.cascade(restriction=new_dict, direction="down", null_on_fail=False)
    oc.cascade_target()
